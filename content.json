{"posts":[{"title":"Java JFileChooser保存文件","text":"如何使用 JFileChooser 保存文件 原文链接: JFileChooser 保存文件 123456789101112131415161718192021222324//创建文件选择器JFileChooser fileChooser = new JFileChooser();//后缀名过滤器FileNameExtensionFilter filter = new FileNameExtensionFilter(&quot;标签文件(*.txt)&quot;, &quot;txt&quot;);fileChooser.setFileFilter(filter);// 在容器上打开文件选择器fileChooser.showSaveDialog(jf);File f=fileChooser.getSelectedFile();//字节输出流FileOutputStream fos = null; try { String fname = f.getName();//从文件名输入框中获取文件名 //创建文件 File file=new File(fileChooser.getCurrentDirectory()+&quot;/&quot;+fname+&quot;.txt&quot;); fos = new FileOutputStream(file); //写入文件操作 String Datas = proDatas.toString(); fos.write(Datas.getBytes()); fos.close(); } catch (IOException e1) { System.err.println(&quot;IO异常&quot;); e1.printStackTrace(); } 关于从文件输入框获取文件名时，使用 fileChooser.getSelectedFile().getName()。但我们是”保存“，并没有选择文件。关于这一点，我引用大佬的解释： 1231、JFileChooser.getSelectedFile()返回一个文件 bai 对象，调这个文件对象的 dugetName()很容易得到用户输入的 zhi 文件名。返回文 dao 件对象既包含了文件路径也包含了文件名，这也体现了 Java 面向对象的思想。2、Java 的文件对象在文件系统中是可以存在，也可不存在的，所以 Java 的文件对象有 exists()、createNewFile()、mkdir()等方法。所以文件保存对话框返回的文件对象不一定在文件系统实际存在，而仅仅是一串路径的表示。","link":"/2020/06/08/Java-JFileChooser%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6/"},{"title":"Java JLabel图片刷新问题","text":"jLabel 设置了图片，当图片文件改变时，展示图片的内容却没有改变 直接用以下方法无法刷新： 1234567JPanel.removeAll();JPanel.repaint();ImageIcon image = new ImageIcon(path);JLabel.setIcon(image);JPanel.add(JLabel);JPanel.validate();label.setIcon(null); 这个方法也不行 1234JLabel.setIcon(new ImageIcon(path));JLabel.repaint();JLabel.updateUI();JLabel.setVisible(true); 解决方案 12ImageIcon image = new ImageIcon(ImageIO.read(new File(path)));JLabel.setIcon(image); 这样子，当图片文件改变时，展示时 JLable 的图片展示也能随着刷新。","link":"/2020/06/16/Java-JLabel%E5%9B%BE%E7%89%87%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98/"},{"title":"Java mousedragged事件时控件闪烁","text":"在使用 Java Swing 做程序时，使用 MouseMotionListener 的 mousedragged 鼠标事件，但拖动时，元素位置闪烁变化 输出了位置数值查看发现位置会往左上角**“瞬移”**。 1import java.awt.event.MouseMotionListener; 123456public void mouseDragged(MouseEvent e) {//鼠标拖动 // TODO Auto-generated method stub panel_lable.setLocation(e.getX(),e.getY());//面板位置随鼠标拖动变化， System.out.println(e.getX()+&quot;,&quot;+e.getY());} 解决方法因为我用的是 awt 的组件,需要使用双缓冲来避免画面的抖动。修改后的代码如下: 123456public void mouseDragged(MouseEvent e) {//鼠标拖动 // TODO Auto-generated method stub panel_lable.setLocation(e.getX()+(int)panel_lable.getLocation().getX(),e.getY()+(int)panel_lable.getLocation().getY());//面板位置随鼠标拖动变化， System.out.println(e.getX()+&quot;,&quot;+e.getY());} 修改后抖动的问题就没有了。","link":"/2020/05/18/Java-mousedragged%E4%BA%8B%E4%BB%B6%E6%97%B6%E6%8E%A7%E4%BB%B6%E9%97%AA%E7%83%81/"},{"title":"Mysql错误提示","text":"Mysql 错误提示 Can‘t create table, errno:165 去掉 my.ini 里面的 innodb_force_recovery = 4 然后重新启动 mysql 服务","link":"/2020/11/17/Mysql%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/"},{"title":"beautyEye输入框中文输入法白屏","text":"在使用 Java Swing 编写程序时引用 beautyEye 以修改样式，但在使用输入框时，输入中文窗口就出现白屏 解决方法：在初始化前加入 System.setProperty(“sun.java2d.noddraw”, “true”); 1234567891011public static void main(String[] args) { try { System.setProperty(&quot;sun.java2d.noddraw&quot;, &quot;true&quot;); org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper.launchBeautyEyeLNF(); } catch (Exception e) { // TODO exception } }","link":"/2020/05/23/beautyEye%E8%BE%93%E5%85%A5%E6%A1%86%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E7%99%BD%E5%B1%8F/"},{"title":"html页面的所有请求都自动将http请求转变为https请求的原因","text":"html 在加载静态资源时自动将 http 请求转化为了 https 解决方法: index.html 头中有如下代码 1&lt;meta http-equiv=“Content-Security-Policy” content=“upgrade-insecure-requests”&gt; 这个代码的作用是将站内加载的资源自动将 http 转为 https如果不需要去掉就可以解决问题。","link":"/2021/04/20/html%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%89%80%E6%9C%89%E8%AF%B7%E6%B1%82%E9%83%BD%E8%87%AA%E5%8A%A8%E5%B0%86http%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%98%E4%B8%BAhttps%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0/"},{"title":"include 和require的区别","text":"require 和 include 都是引入文件，有什么区别呢？ include 和 require 的区别前言require 和 include 都是引入文件，有什么区别呢？ requirerequire 这个函数通常放在 PHP 程序的最前面，PHP 程序在执行前，就会先读入 require 所指定引入的文件，使它变成 PHP 程序网页的一部份。常用的函数，亦可以这个方法将它引入网页中。 includeinclude 这个函数一般是放在流程控制的处理部分中。PHP 程序网页在读到 include 的文件时，才将它读进来。可以把程序执行时的流程简单化。 区别 Php 在遇到 include 时就解释一次，如果页面中出现 10 次 include ，php 就解释 10 次，而 php 遇到 require 时只解释一次，即使页面出现多次 require 也只解释一次，因此 require 的执行表率比 include 高。 Php 使用 require 包含文件时将被包含的文件当成当前文件的一个组成部分，如果被包含的文件中有语法错误或者被包含的文件不存在，则 php 脚本将不再执行，并提示错误。 Php 使用 include 包含文件时相当于指定了这个文件的路径，当被包含的文件有语法错误或者被包含的文件不存在时给出警告，不影响本身脚本的运行。 Include 在包含文件时可以判断文件是否包含，而 require 则不管任何情况都包含进来。 Require 的效率比 require_once 的效率更高，因为 require_once 在包含文件时要进行判断文件是否已经被包含。","link":"/2019/04/17/include-%E5%92%8Crequire%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"npm install报错","text":"在前端项目里安装安装 gulp 的时候，出现了如下 “Sorry, name can only contain URL-friendly characters.” 这是因为在 npm 初始化的时候，会向我们询问项目名，如果我们不命名回车跳过的话，它会指定你的文件件的名称当做项目名。但是我的项目名称是不规范的有了两个-，所以需要重新npm install gulp –save-dev一下，在询问项目名的时候定义一下，比如说 police。然后其他的信息可以先不填后期填。 最后确认","link":"/2021/03/16/npm-install%E6%8A%A5%E9%94%99/"},{"title":"python爬虫读取ins照片问题总结","text":"在使用 python 爬取 ins 照片时遇到的一些问题 出现该报错时添加cookies 这是库ulllib3版本的错误。使用pip install urllib3==1.25.8，降低urllib3的版本 但安装时出现报错 12ERROR: Could not find a version that satisfies the requirement urllib3ERROR: No matching distribution found for urllib3 解决方法:因为 python 国内网站网络不稳定的问题，于是使用镜像 1pip install 包的名字 -i http://pypi.doubanio.com/simple/ --trusted-host pypi.doubanio.com","link":"/2021/03/16/python%E7%88%AC%E8%99%AB%E8%AF%BB%E5%8F%96ins%E7%85%A7%E7%89%87%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"静态页面实现 include 引入公用代码","text":"静态页面实现 include 引入公用代码的示例 原文链接: 静态页面实现 include 引入公用代码的示例 一直以来，我司的前端都是用 php 的 include 函数来实现引入 header 、footer 这些公用代码的，就像下面这样： 12345678910111213141516&lt;!-- index.php --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php include('header.php'); ?&gt; &lt;div&gt;页面主体部分&lt;/div&gt; &lt;?php include('footer.php'); ?&gt; &lt;/body&gt;&lt;/html&gt; 12&lt;!-- header.php --&gt;&lt;header&gt;这是头部&lt;/header&gt; 12&lt;!-- footer.php --&gt;&lt;footer&gt;这是底部&lt;/footer&gt; 直到最近某个项目需要做一个 webapp，是通过 HBuilder 将静态页面打包成 APP，这就让我碰到难题了。如果是小项目，那就直接手动多复制粘贴几遍，但如果页面较多，复制粘贴的方案明显不靠谱，维护成本也高。在查了很多资料后，最终确定用 gulp 来解决，具体操作如下： 安装 gulp 和 gulp-file-include首先新建个文件夹，在终端里定位到文件夹的位置，然后进行 npm 初始化 1npm init 然后安装 gulp 1npm install gulp --save-dev 接着安装 gulp-file-include 1npm install gulp-file-include --save-dev 新建并配置 gulpfile.js接着我们手动新建一个 js 文件取名为 gulpfile，并在里面写入如下代码： 123456789101112131415var gulp = require(&quot;gulp&quot;);var fileinclude = require(&quot;gulp-file-include&quot;);gulp.task(&quot;fileinclude&quot;, function () { // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html gulp .src([&quot;page/**/*.html&quot;, &quot;!page/include/**.html&quot;]) .pipe( fileinclude({ prefix: &quot;@@&quot;, basepath: &quot;@file&quot;, }) ) .pipe(gulp.dest(&quot;dist&quot;));}); 创建项目目录结构，并添加测试代码项目的整体目录结构应该是这样 123456789101112131415app page include header.html footer.html index.html gulpfile.js package.json 然后我们添加测试代码，header.html 和 footer.html 没太多好说的，主要是 index.html 要特别注意引入的方式，代码如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @@include('include/header.html') &lt;div&gt;页面主体部分&lt;/div&gt; @@include('include/footer.html') &lt;/body&gt;&lt;/html&gt; 运行在终端里敲入以下代码，看执行效果 1gulp fileinclude 会发现，多了个 dist 文件夹，里面有一个 index.html 文件，gulp-file-include 已经帮我们把最终编译好的 index.html 文件生成好了。可能你已经能举一反三了，在 gulpfile.js 里，我们可以手动设置最终生成文件的位置，就是这句话 1gulp.dest('dist') 自动编译静态页面引入公用代码的问题已经解决了，但每次编写源 html 后，都要去终端里手动执行下编译操作还是很麻烦，那能不能让文件自动编译呢？答案一定是可以的。 gulp 有个 watch 方法，就是监听文件是否有变动的，我们只需稍微修改下 gulpfile.js 文件，增加一段监听代码，如下： 12345678910111213141516171819var gulp = require(&quot;gulp&quot;);var fileinclude = require(&quot;gulp-file-include&quot;);gulp.task(&quot;fileinclude&quot;, function () { // 适配page中所有文件夹下的所有html，排除page下的include文件夹中html gulp .src([&quot;page/**/*.html&quot;, &quot;!page/include/**.html&quot;]) .pipe( fileinclude({ prefix: &quot;@@&quot;, basepath: &quot;@file&quot;, }) ) .pipe(gulp.dest(&quot;dist&quot;));});gulp.task(&quot;watch&quot;, function () { gulp.watch(&quot;page/**/*.html&quot;, [&quot;fileinclude&quot;]);}); 写好之后，我们只需在终端里执行 1gulp watch 我们每次保存源 html 后，gulp 就会自动帮我们编译一遍。 原文地址","link":"/2021/03/16/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0-include-%E5%BC%95%E5%85%A5%E5%85%AC%E7%94%A8%E4%BB%A3%E7%A0%81/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"jLabel","slug":"jLabel","link":"/tags/jLabel/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"beautyEye","slug":"beautyEye","link":"/tags/beautyEye/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"}],"categories":[{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"bug","slug":"编程/bug","link":"/categories/%E7%BC%96%E7%A8%8B/bug/"},{"name":"php","slug":"编程/php","link":"/categories/%E7%BC%96%E7%A8%8B/php/"}],"pages":[{"title":"","text":"google-site-verification: google79f2654ba7660547.html","link":"/google79f2654ba7660547"},{"title":"","text":"页面未找到","link":"/404/"},{"title":"关于我","text":"普通的社畜，喜欢各种有意思的玩意，目前是一名前端开发工程师，有两只可爱的小猫咪。 个人项目： 没猫病小程序","link":"/about/"},{"title":"爱好作品","text":"石塑粘土 手绘 像素画","link":"/hobby/"}]}